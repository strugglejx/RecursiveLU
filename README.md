# RecursiveLU
## 项目介绍
RecursiveLU是基于ARMv8处理器架构的SIMD汇编优化程序，实现了现有递归LU 分解算法的分块以及SIMD汇编优化。
## 目录结构
```
├── src
│     ├── main.c
│     ├── test.h
└─────└── cal
          ├── LU_ASM_1.c
          ├── LU_ASM_2.c
          ├── LU_ASM_3.c
          ├── LU_C_Optimize.c
          └── LU_C.c
```
## 编译
``` Shell
gcc -O3 main.c -o main
```
## 执行
``` Shell
./main -o $矩阵阶数 -n $循环次数
```
## 实验环境
| 属性 	| 参数 	|
|:---:	|:---:	|
| CPU型号 	| 飞腾 FT-2000/4 	|
| CPU个数 	| 1个 CPU / 4个核心 	|
| 内存 	| 8GB 	|
| 一级缓存 	| 32KB 数据缓存 / 32KB 指令缓存 	|
| 二级缓存 	| 4MB 	|
| 三级缓存 	| 4MB 	|
| 指令集 	| aarch64 	|

## 矩阵乘法
矩阵A = B * C，其中A的大小为N * M，B的大小为N * L，C的大小为L * M。对于最优的遍历顺序i->k->j，仍然存在优化的空间。优化的方法有：
1. 对于矩阵A和C来说，需要进行L次的行遍历，可优化的点在于：对A和C的行进行分块（块大小为T2，可设置大一些，因为相邻元素的空间局部性较好，且可以减少条件判断的次数），可增加矩阵A和矩阵C上T2大小的块的重用性，充分利用高速缓存的时间局部性。
2. 对于矩阵C来说，需要进行N次的列遍历，而对于矩阵B来说，需要进行 M / T2 次遍历。可优化的点在于：对C的列进行分块（块大小为T1，可设置为8或以上，不可设置太小否将增加条件判断的次数），可增加矩阵B在行方向上T1大小的小块的重用性，以及与矩阵B对应的 T1 * T2 小块的重用性，充分利用高速缓存的时间局部性（C的列方向以及B的行方向）。
3. 对于矩阵C来说，T1 * T2小块需要进行N次遍历，可优化的点在于：对A的列进行分块（块大小为T3，可设置为4或8，尽可能设小一些，因为按列遍历空间局部性并不好），可增加矩阵C上T1 * T2小块的重用性，即充分利用高速缓存的时间局部性。
``` C++
void MatMulti(double **A, double **B, double **C) { // 对C的行分块，再对C的列分块，最后对A的行分块
  for (int i = 0; i < N; i += T3) {
    for (int k = 0; k < L; k += T1) {
      for (int j = 0; j < L; j += T2) {
        for (int ii = i; ii < i + T3; ++ii) {
          for (int kk = k; kk < k + T1; ++kk) {
            for (int jj = j; jj < j + T2; ++jj) {
              A[ii][jj] += B[ii][kk] * C[kk][jj];
            }
          }
        }
      }
    }
  }
}
```

## 递归LU分解的分块以及SIMD优化
针对LU分解的计算使用到了以下三点优化：
1. 递归LU：将LU进行矩阵分块，再利用数学公式推导得到LU分解的递推式，由这个递推式可以得到一个矩阵相乘的模块，经过计算可知，这个矩阵相等的模块的复杂度最高，为O(n^3)。这个递归方法大大减少了原来的LU分解中复杂的边界条件的判断，进而提升算法性能。
2. 矩阵乘法模块的优化：该模块涉及到的计算为A = A - B * C，其中A的大小为N * M，B的大小为N * L，C的大小为L * M。而在递归LU中，为了尽可能发挥递归LU的优势，因此L设置得较小，实验中固定为8。接下来就能利用到矩阵乘法中分块的优化技巧（其中矩阵B的列维度并不做分块），可对矩阵A和矩阵C的行进行分块，分块大小为T2，再对矩阵A的列进行分块，分块大小为T3。
3. SIMD优化：对优化3中的大小为T2 * T3的小块的遍历进行优化，如下图中的右半部分，为了减少寄存器与内存之间的读写次数，可采用先按列遍历，再按行遍历的方式，因为按列遍历可以减少v8.2d到v23.2d寄存器的读入及写出的次数。另外，利用SIMD指令还能实现数据间的并行加速。

## 实验结果
实验结果在以下参数下得到： 矩阵大小为512 × 512，分块矩阵的大小为 4 × 64。
| 算法  	| 时间 	|
|:---:	|:---:	|
| 递归 LU 分解（C 语言）  	| 3839746 	|
| 递归 LU 分解（SIMD汇编）  	| 3266809 	|
| 递归 LU 分解+双重分块策略优化（C 语言） 	| 6464961 	|
| 递归 LU 分解+双重分块策略优化（SIMD汇编） 	| 2598728 	|
<br>
注：表中“递归分块的 LU 分解（C 语言）”是本文实验的基准， 后续的双重分块策略优化以及SIMD 汇编优化将在该算法的基础上进行， 为了得到更有效的加速比， 本文的 C 语言代码都将采用指针进行优化； 
第二个算法“ 递归分块的 LU 分解（SIMD汇编）” 是对递归 LU 分解采用了 SIMD 内联汇编进行优化， 但不采用双重分块策略进行优化；
第三个算法“递归分块的 LU 分解+双重分块策略优化（ C 语言）” 对第一个算法使用 C 语言进行了双重分块策略进行优化； 
第四个算法“递归分块的 LU 分解+双重分块策略优化（SIMD汇编）” 对第三个算法进行了 SIMD 内联汇编优化。
